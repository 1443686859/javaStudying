package cn.learning.staticlearning;
//内部类说明
/**
 * 在Java中，可以将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类。
 * 广泛意义上的内部类一般来说包括这四种：成员内部类、局部内部类、匿名内部类和静态内部类。
 */
//成员内部类
/**
 *成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）。
 * 不过要注意的是，当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问：
 *
 * 外部类.this.成员变量
 * 外部类.this.成员方法
 *
 *
 * 虽然成员内部类可以无条件地访问外部类的成员，而外部类想访问成员内部类的成员却不是这么随心所欲了。
 * 在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问：
 *
 * 我的想法将成员内部类，视作一名成员，而外部类只有成员内部类的定义但是没有他的操作对象，成员内部类相当于外部类中的方法可以自由访问外部类变量
 *
 *
 * 内部类可以拥有private访问权限、protected访问权限、public访问权限及包访问权限（即默认无修饰符），
 * 外部类只能被public和包访问两种权限修饰。
 *
 */


//局部内部类
/**
 * 局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。
 * 局部内部类定义在方法中，比方法的范围还小。是内部类中最少用到的一种类型。
 * 像局部变量一样，不能被public, protected, private和static修饰。
 * 只能访问方法中定义的final类型的局部变量。
 */

public class Inclass {
    //public class tr<T>{};
    public void add(){
       // static int d;无法在局部方法内使用static关键词修饰变量；这行编译器会报错
        //public int d;无法在局部方法内使用public关键词修饰变量；同上
    // protected int d;同上
        // private int d;同上

    }
    public static void main(String[] args) {

    }
}
//匿名内部类
    /**
     *
     *用匿名内部类能够在实现父类或者接口中的方法情况下同时产生一个相应的对象
     * package org.hammerc.study;
     *
     * public class Main
     * {
     *     public static void main(String[] args)
     *     {
     *         new Main();
     *     }
     *
     *     private ICallback callback;
     *
     *     public Main()
     *     {
     *         test(100);
     *     }
     *
     *     private void test(final int a)
     *     {
     *         final String b = "abc";
     *
     *         callback = new ICallback()
     *         {
     *             @Override
     *             public void Handler()
     *             {
     *                 System.out.println("a: " + a + ", b: " + b);
     *             }
     *         };
     *
     *         callback.Handler();
     *     }
     * }
     *
     * interface ICallback
     * {
     *     void Handler();
     * }
     *，Java8之前的版本中还没有很好的对闭包进行支持，
     * 由于局部变量的生命周期与局部内部类的对象的生命周期的不一致性，
     * 回调可能会在离开其访问的对象的作用域时调用，
     * 比如一个异步的操作，这样就会导致回调执行获取一个参数或临时变量时，
     * 该参数或变量已经被销毁的情况。
     *
     */
    //静态内部类
/**
 *静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static。静态内部类是不需要依赖于外部类的，
 * 这点和类的静态成员属性有点类似，并且它不能使用外部类的非static成员变量或者方法，这点很好理解，
 * 因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非static成员就会产生矛盾，
 * 因为外部类的非static成员必须依附于具体的对象。
 *
 * 我们都知道，Java中一个文件只能包含一个对外公开的类，
 * 且类名必须和文件名一致，那么如果我们需要再一个类中定义多个对外公开的类该怎么办？
 * 答案就是使用静态内部类。
 *
 *
 */